(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vue-input-facade"] = factory();
	else
		root["vue-input-facade"] = factory();
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "InputFacade", function() { return /* reexport */ src_component; });
__webpack_require__.d(__webpack_exports__, "facade", function() { return /* reexport */ directive; });
__webpack_require__.d(__webpack_exports__, "tokens", function() { return /* reexport */ src_tokens; });
__webpack_require__.d(__webpack_exports__, "masker", function() { return /* reexport */ masker; });
__webpack_require__.d(__webpack_exports__, "filter", function() { return /* reexport */ filter; });

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./src/tokens.js
/* harmony default export */ var src_tokens = ({
  '#': {
    pattern: /\d/
  },
  X: {
    pattern: /[0-9a-z]/i
  },
  S: {
    pattern: /[a-z]/i
  },
  A: {
    pattern: /[a-z]/i,
    transform: v => v.toLocaleUpperCase()
  },
  a: {
    pattern: /[a-z]/i,
    transform: v => v.toLocaleLowerCase()
  },
  '\\': {
    escape: true
  },
  '?': {
    optional: true
  },
  '*': {
    repeat: true
  },
  '|': {
    pipe: true
  }
});
// CONCATENATED MODULE: ./src/core.js

const CONFIG_KEY = '__input-facade__';
function FacadeValue(val) {
  this.masked = this.unmasked = val || '';
}
/**
 * Creates a CustomEvent('input') with detail = { facade: true }
 * used as a way to identify our own input event
 */

function FacadeInputEvent() {
  return new CustomEvent('input', {
    bubbles: true,
    cancelable: true,
    detail: {
      facade: true
    }
  });
}
/**
 * Transform an array or string config into an object
 *
 * @param {object} config The mask config object
 * @param {object} modifiers An object of modifier flags that can influence the masking process
 */

function normalizeConfig(config, modifiers) {
  if (Array.isArray(config) || typeof config === 'string') {
    config = {
      mask: config
    };
  }

  return Object.assign(config || {}, modifiers);
}
/**
 * ensure that the element we're attaching to is an input element
 * if not try to find an input element in this elements childrens
 *
 * @param {HTMLInputElement} el
 */

function getInputElement(el) {
  const inputElement = el instanceof HTMLInputElement ? el : el.querySelector('input');
  /* istanbul ignore next */

  if (!inputElement) {
    throw new Error('facade directive requires an input element');
  }

  return inputElement;
}
/**
 * Input event handler
 *
 * @param {Event} event The event object
 */

function inputHandler(event) {
  const {
    target,
    detail,
    inputType
  } = event; // We dont need to run this method on the event we emit (prevent event loop)

  if (detail !== null && detail !== void 0 && detail.facade) {
    return false;
  } // since we will be emitting our own custom input event
  // we can stop propagation of this native event


  event.stopPropagation(); // Ignore input events related to composition, specific composition
  // events will handle updating the input after text is composed

  if (['insertCompositionText', 'insertFromComposition'].includes(inputType)) {
    return false;
  }

  const originalValue = target.value;
  const originalPosition = target.selectionEnd;
  const {
    oldValue
  } = target[CONFIG_KEY];
  updateValue(target, null, {
    emit: false
  }, event);
  updateCursor(event, originalValue, originalPosition);

  if (oldValue !== target.value) {
    target.dispatchEvent(FacadeInputEvent());
  }
}
/**
 * Updates the cursor position to the right place after the masking rule was applied
 *
 * @param {InputEvent} event the event that trigger this update
 * @param {String} originalValue the original input value, prior to masking
 * @param {Number} originalPosition the original cursor position
 */

function updateCursor(event, originalValue, originalPosition) {
  const {
    target
  } = event; // setSelectionRange applies only to inputs of types text, search, URL, tel and password.
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange

  const supportedInputType = ['text', 'tel', 'search', null].includes(target.getAttribute('type'));
  const config = target[CONFIG_KEY] && target[CONFIG_KEY].config;

  if (target !== document.activeElement || !supportedInputType || !config.mask && !config.masked) {
    return;
  } // if event.inputType is not supported, assume 'insertText'


  const inputType = event.inputType || 'insertText'; // get some information about the cursor based on the original value

  const isInsertEvent = ['insertText', 'insertFromPaste'].includes(inputType);
  const wasCursorAtEnd = isInsertEvent && originalPosition == originalValue.length;
  let lastInsertedChar = isInsertEvent && originalValue[originalPosition - 1];
  const newValue = target.value.toLocaleLowerCase(); // set the cursor position to an appropriate location

  let cursorPosition = originalPosition;

  if (wasCursorAtEnd) {
    cursorPosition = newValue.length;
  } else if (lastInsertedChar) {
    lastInsertedChar = lastInsertedChar.toLocaleLowerCase();
    let newPosition = cursorPosition; // if the last inserted char was changed, increment position until find it again

    while (newPosition <= newValue.length && newValue.charAt(newPosition - 1) !== lastInsertedChar) {
      newPosition++;
    } // if we didnt find the digit must be an unacceptable char, leave the cursor where it was


    cursorPosition = newPosition <= newValue.length ? newPosition : cursorPosition - 1;
  }

  target.setSelectionRange(cursorPosition, cursorPosition);
  /* istanbul ignore next */

  setTimeout(function () {
    target.setSelectionRange(cursorPosition, cursorPosition);
  }, 0);
}
/**
 * Updates the element's value and unmasked value based on the masking config rules
 *
 * @param {HTMLInputElement} el The input element to update
 * @param {object} [options]
 * @param {Boolean} options.emit Wether to dispatch a new InputEvent or not
 * @param {Boolean} options.force Forces the update even if the old value and the new value are the same
 * @param {Event} [event] The event that triggered this this update, null if not triggered by an input event
 */

function updateValue(el, vnode, {
  emit = true,
  force = false
} = {}, event) {
  var _vnode$data, _vnode$data$model;

  let {
    config,
    oldValue,
    isComposing
  } = el[CONFIG_KEY];
  let currentValue = (vnode === null || vnode === void 0 ? void 0 : (_vnode$data = vnode.data) === null || _vnode$data === void 0 ? void 0 : (_vnode$data$model = _vnode$data.model) === null || _vnode$data$model === void 0 ? void 0 : _vnode$data$model.value) || el.value; // manipulating input value while text is being composed can lead to inputs being duplicated

  if (isComposing) {
    return;
  }

  oldValue = oldValue || '';
  currentValue = currentValue || '';

  if (force || oldValue !== currentValue) {
    if (['deleteByCut', 'deleteContent', 'deleteContentBackward', 'deleteContentForward'].includes(event === null || event === void 0 ? void 0 : event.inputType)) {
      config = { ...config,
        short: true
      };
    }

    let newValue = masker(currentValue, config);

    if (event && typeof config.formatter === 'function') {
      const formattedValue = config.formatter(newValue, event);

      if (typeof formattedValue === 'string') {
        newValue = masker(formattedValue, config);
      } else if (formattedValue === false) {
        el.value = oldValue;
        return;
      }
    }

    el[CONFIG_KEY].oldValue = newValue.masked;
    el.unmaskedValue = newValue.unmasked; // safari makes the cursor jump to the end if el.value gets assign even if to the same value

    if (el.value !== newValue.masked) {
      el.value = newValue.masked;
    } // this part needs to be outside the above IF statement for vuetify in firefox
    // drawback is that we endup with two's input events in firefox


    emit && el.dispatchEvent(FacadeInputEvent());
  }
}
// CONCATENATED MODULE: ./src/masker.js


let tokenDefinitions = src_tokens;
let isLocaleCompareSupported = false;

try {
  // if supported this will throw a RangeError because 'i' is not a valid locale
  'a'.localeCompare('b', 'i');
} catch (e) {
  isLocaleCompareSupported = e.name === 'RangeError';
}
/**
 * Overrides the default global token definitions
 *
 * @param {object} tokens the new token object
 */


function setTokens(tokens) {
  /* istanbul ignore if */
  if (!tokens) return;
  tokenDefinitions = tokens;
}
/**
 * Given an array of masks, determines which one is the appropriate one based on the value
 *
 * @param {String} inputValue the inputValue value to mask
 * @param {object} config
 * @param {Array} config.masks the list of masks to choose from
 * @returns {FacadeValue} facade value object
 */

function dynamic(inputValue, config) {
  const masks = config.masks.slice().sort((a, b) => a.length - b.length);

  const withConfig = overrides => Object.assign({}, config, overrides); // this method will choose a facade based on which one exposes more data from the input


  const chooseBestFacade = (currentValue, nextMask) => {
    const nextValue = formatter(inputValue, withConfig({
      mask: nextMask
    }));
    const currentLength = currentValue.unmasked.length;
    const nextLength = nextValue.unmasked.length;
    return nextLength > currentLength ? nextValue : currentValue;
  }; // empty masks array


  if (!masks.length) {
    return new FacadeValue();
  }

  const firstMask = masks.shift();
  let output = formatter(inputValue, withConfig({
    mask: firstMask
  }));

  while (masks.length) {
    const nextMask = masks.shift();
    output = chooseBestFacade(output, nextMask);
  }

  return output;
}
/**
 * Formats the value based on the given masking rule
 *
 * @param {string} value the value to mask
 * @param {object} config
 * @param {string} config.mask the masking string
 * @param {object} config.tokens the tokens to add/override to the global
 * @param {boolean} config.prefill whether or not to add masking characters to the input before the user types
 * @param {boolean} config.short to keep the string as short as possible (not append extra chars at the end)
 */

function formatter(value, config) {
  let {
    mask = '',
    tokens,
    prefill = false,
    short = false
  } = config; // append/override global tokens instead of complete override

  tokens = tokens ? Object.assign({}, tokenDefinitions, tokens) : tokenDefinitions;
  let output = new FacadeValue();
  let escaped = false;
  let valueIndex = 0;
  let maskIndex = 0;
  let accumulator = ''; // gets some information about the mask before formating

  function getMetaData(masker) {
    const nextMaskChar = mask[maskIndex + 1];
    const nextMasker = tokens[nextMaskChar];
    return {
      escape: !!(masker !== null && masker !== void 0 && masker.escape),
      optional: !!(nextMasker !== null && nextMasker !== void 0 && nextMasker.optional),
      repeat: !!(nextMasker !== null && nextMasker !== void 0 && nextMasker.repeat),
      ...((nextMasker === null || nextMasker === void 0 ? void 0 : nextMasker.pipe) && {
        pipe: mask.substring(maskIndex).match(/^(.\|)+./g)[0].split('|')
      })
    };
  }

  while (maskIndex < mask.length) {
    const maskChar = mask[maskIndex];
    const masker = tokens[maskChar];
    let char = value[valueIndex];
    const meta = getMetaData(masker);

    if (masker && !escaped && !meta.pipe) {
      var _masker$pattern;

      // when is escape char, do not mask, just continue
      if (meta.escape) {
        escaped = true;
        maskIndex++;
        continue;
      } // no more input characters and next character is a masked one


      if (!char) break;

      if ((_masker$pattern = masker.pattern) !== null && _masker$pattern !== void 0 && _masker$pattern.test(char)) {
        var _masker$transform;

        char = ((_masker$transform = masker.transform) === null || _masker$transform === void 0 ? void 0 : _masker$transform.call(masker, char)) || char;
        output.unmasked += char;
        output.masked += accumulator + char;
        accumulator = '';

        if (!meta.repeat) {
          maskIndex += meta.optional ? 2 : 1;
        }
      } else if (meta.optional || meta.repeat) {
        maskIndex += 2;
        continue;
      }

      valueIndex++;
    } else if (meta.pipe) {
      if (!char) break;
      const pipeMatch = meta.pipe.find(looselyStringMatch.bind(null, char));

      if (pipeMatch) {
        output.unmasked += pipeMatch;
        output.masked += accumulator + pipeMatch;
        maskIndex += meta.pipe.length * 2 - 1;
        accumulator = '';
      }

      valueIndex++;
    } else {
      if (looselyStringMatch(char, maskChar)) {
        // user typed the same char as static mask char
        output.masked += accumulator + maskChar;
        valueIndex++;
        accumulator = '';

        if (meta.optional) {
          output.unmasked += maskChar;
        }
      } else if (!meta.optional) {
        accumulator += maskChar;
      }

      escaped = false;
      maskIndex += meta.optional ? 2 : 1;
    }
  } // if there is no unmasked value, set masked to empty to avoid showing masking
  // characters in an otherwise empty input, unless prefill is set ot true


  if (prefill && !output.unmasked || !short && output.unmasked) {
    output.masked += accumulator;
  }

  return output;
}
/**
 * Loosely compare two strings and returns if they are equal ignoring case and locale
 * specific accents. Some browsers do not fully support this (Android webview and opera)
 * so we fallback to just ignoring casing in those cases.
 *
 * @see [MDM - LocaleCompare](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)
 *
 * @param {String} str1 String one
 * @param {String} str2 String two
 * @returns Boolean
 */

function looselyStringMatch(str1, str2) {
  /* istanbul ignore else */
  if (isLocaleCompareSupported) {
    return (str1 === null || str1 === void 0 ? void 0 : str1.localeCompare(str2, undefined, {
      sensitivity: 'base'
    })) === 0;
  } else {
    return (str1 === null || str1 === void 0 ? void 0 : str1.toLocaleLowerCase()) === (str2 === null || str2 === void 0 ? void 0 : str2.toLocaleLowerCase());
  }
}
/**
 * Facade to formatter/dynamic when mask is String or Array
 *
 * @param {String} value the value to mask
 * @param {*} config the masking config
 * @returns {FacadeValue} facade value object
 */

function masker(value, config) {
  // ensure we have proper input
  value = (value || '').toString();
  config = normalizeConfig(config); // disable on empty mask

  if (!config.mask) {
    return new FacadeValue(value);
  }

  return Array.isArray(config.mask) ? dynamic(value, Object.assign({}, config, {
    masks: config.mask
  })) : formatter(value, config);
}
// CONCATENATED MODULE: ./src/directive.js

const directive_CONFIG_KEY = CONFIG_KEY;
/* harmony default export */ var directive = ({
  bind: (el, {
    value,
    modifiers
  }, vnode) => {
    el = getInputElement(el);
    const config = normalizeConfig(value, modifiers);
    el[directive_CONFIG_KEY] = {
      config
    }; // set initial value

    updateValue(el, vnode, {
      force: config.prefill
    });
  },
  inserted: el => {
    el = getInputElement(el);
    const config = el[directive_CONFIG_KEY]; // prefer adding event listener to parent element to avoid Firefox bug which does not
    // execute `useCapture: true` event handlers before non-capturing event handlers

    const handlerOwner = el.parentElement || el; // use anonymous event handler to avoid inadvertently removing masking for all inputs within a container

    const handler = e => {
      if (e.target !== el) {
        return;
      }

      inputHandler(e, el);
    };

    const compositionHandler = e => {
      if (e.target !== el) {
        return;
      }

      if (e.type === 'compositionend') {
        el[directive_CONFIG_KEY].isComposing = false;
        inputHandler(e, el);
      } else {
        el[directive_CONFIG_KEY].isComposing = true;
      }
    };

    handlerOwner.addEventListener('input', handler, true);
    handlerOwner.addEventListener('compositionstart', compositionHandler, true);
    handlerOwner.addEventListener('compositionupdate', compositionHandler, true);
    handlerOwner.addEventListener('compositionend', compositionHandler, true);

    config.cleanup = () => {
      handlerOwner.removeEventListener('input', handler, true);
      handlerOwner.removeEventListener('compositionstart', compositionHandler, true);
      handlerOwner.removeEventListener('compositionend', compositionHandler, true);
      handlerOwner.removeEventListener('compositionupdate', compositionHandler, true);
    };
  },
  update: (el, {
    value,
    oldValue,
    modifiers
  }, vnode) => {
    el = getInputElement(el);

    if (value !== oldValue) {
      el[directive_CONFIG_KEY].config = normalizeConfig(value, modifiers);
      updateValue(el, vnode, {
        force: true
      });
    } else {
      updateValue(el, vnode);
    }
  },
  unbind: el => {
    getInputElement(el)[directive_CONFIG_KEY].cleanup();
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"84ec35d2-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/component.vue?vue&type=template&id=ff164674&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('input',{directives:[{name:"facade",rawName:"v-facade",value:(_vm.config),expression:"config"}],attrs:{"type":"text"},domProps:{"value":_vm.maskedValue},on:{"input":_vm.onInput,"change":_vm.onChange,"blur":function($event){return _vm.$emit('blur')},"focus":function($event){return _vm.$emit('focus')}}})}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/component.vue?vue&type=template&id=ff164674&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/component.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//

/**
 * The component is basically a wrapper around a native input element, as such it inherits all
 * properties available to [HTMLInputElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement).
 *
 * However it provides a cleaner and more straight forward interface to the directive's features.
 *
 * @example ../docs/component.md
 */

/* harmony default export */ var componentvue_type_script_lang_js_ = ({
  name: 'InputFacade',
  props: {
    /**
     * A function to format the value after applying the mask. The function will receive an
     * object with the masked and unmasked value. The result of this function will determine
     * what happens with the value.
     * <br />
     * If a string is returned, then that string will pass through the masker function once more and its value
     * will be set to the input.  If false (boolean) is returned, the input will be rejected and the
     * previous value will be restored.  Otherwise the facade logic will continue as usual.
     * @since v1.3
     */
    formatter: Function,

    /**
     * Vue's v-model .lazy modifier does not currently work with custom components. If you wish to have your v-model
     * updated only during the change event instead of on input, enable this property. <b>Note: This works by supressing
     * input events and only emitting a single input event at the same time as the change event.</b>
     * @since v1.3
     */
    lazy: {
      type: Boolean,
      default: false
    },

    /**
     * The mask pattern for this input, it could be a single pattern or multiple patterns when its an array.
     */
    mask: [String, Array],

    /**
     * Whether to emit the value masked or unmasked
     */
    masked: {
      type: Boolean,
      default: false
    },

    /**
     * If the mask starts with static charaters, prefill the field with said characters
     * @since v1.3
     */
    prefill: {
      type: Boolean,
      default: false
    },

    /**
     * Keep the value short by not showing static characters until after typing
     * @since v1.3
     */
    short: {
      type: Boolean,
      default: false
    },

    /**
     * Token object to override the defaults with
     */
    tokens: Object,

    /**
     * The input's value
     * @model
     */
    value: [String, Number]
  },
  directives: {
    facade: directive
  },

  data() {
    return {
      maskedValue: this.value,
      unmaskedValue: null
    };
  },

  watch: {
    value(newValue) {
      // avoid trigering the directive's update hook when we emit
      // the unmasked value to the parent component
      if (newValue !== this.emittedValue) {
        this.maskedValue = newValue;
      }
    },

    mask(newMask) {
      if (!newMask && !this.masked) {
        // when removing the masking rule, set the displayed value to the unmasked
        // to remove any unwanted masking characters from the input
        this.maskedValue = this.unmaskedValue;
      }
    },

    masked() {
      this.emitInput();
    }

  },
  computed: {
    config() {
      return {
        mask: this.mask,
        masked: this.masked,
        tokens: this.tokens,
        formatter: this.formatter,
        prefill: this.prefill,
        short: this.short
      };
    },

    emittedValue() {
      return this.mask && this.masked ? this.maskedValue : this.unmaskedValue;
    }

  },
  methods: {
    onInput({
      target
    }) {
      this.maskedValue = target.value;
      this.unmaskedValue = target.unmaskedValue;

      if (!this.lazy) {
        this.emitInput();
      }
    },

    onChange() {
      /**
       * Fires when the value has been commited on the input. Usually on blur.
       * @param {String} value The input's current value, masked or unmasked.
       */
      this.$emit('change', this.emittedValue);

      if (this.lazy) {
        this.emitInput();
      }
    },

    emitInput() {
      /**
       * Fires when the value of the input has been changed.
       * @param {String} value The input's current value, masked or unmasked.
       */
      this.$emit('input', this.emittedValue);
    }

  }
});
// CONCATENATED MODULE: ./src/component.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_componentvue_type_script_lang_js_ = (componentvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./src/component.vue





/* normalize component */

var component = normalizeComponent(
  src_componentvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_component = (component.exports);
// CONCATENATED MODULE: ./src/plugin.js




/**
 * Vue plugin definittion
 *
 * @param {Vue} Vue the vue instance
 * @param {Object} options.tokens the tokens to use as global tokens
 * @param {Object} options.name the tokens to use as global tokens
 */

function install(Vue, options = {}) {
  // override the default tokens
  if (options.tokens) {
    setTokens(options.tokens);
  }

  Vue.component(src_component.name, src_component);
  Vue.directive(options.name || 'facade', directive);
  Vue.filter(options.name || 'facade', filter);
}
/**
 * Utility function to be used as a vue filter
 *
 * @param {String} value the value to apply the filter to
 * @param {*} config the masking config
 * @returns {string} the masked value as returned by the masker function
 */


function filter(value, config) {
  return masker(value, config).masked;
}

/* harmony default export */ var src_plugin = (install);
 // Install by default if included from script tag

if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(install);
}
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (src_plugin);



/***/ })

/******/ });
});