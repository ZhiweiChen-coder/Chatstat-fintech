<script lang="js" backend on="middleware">
const _ = require('lodash');
const debug = require('debug')('doop:timeseries-chart');
const moment = require('moment');

/**
* Middleware to return a v-chart-timeseries compatible timeseries dataset
* @param {object} options Options to use to generate the middleware
* @param {string} options.collection Collection to return the timeseries of
* @param {string} [options.field='created'] Collection field to iterate the time series by, must be a date. All non-dates are removed
* @param {string} [options.field2='status'] Secondary field to iterate through
* @param {array} [options.values] Values to return as sets from the secondary field, defaults to using the enum set of the field
* @param {function} [options.valueLabel] Function called as `(value, offset, dataSet, settings)` to rewrite a value, default is to use _.startCase()
* @param {boolean} [options.fixDates=true] Whether to preparse the field into a valid Mongo date before iterating, this fixes string date storage
* @param {function} [options.interval] Promisable function called as `(req, res, settings)` which should return the interval of the timeseries, defaults to parsing req.query.interval via timestring or '1d'
* @param {function} [options.timeLabel] Function called as `(req, res, date)` to neaten the date display, defaults to using Moment to return a simple local date
* @param {function} [options.start] Promisable function called as `(req, res, settings)` which should return the starting point of the timeseries, defaults to parsing req.query.start via moment or 1 week ago if req.query.start is unspecified
* @param {function} [options.end] Promisable function called as `(req, res, settings)` which should return the starting point of the timeseries, defaults to parsing req.query.start via moment or 1 week ago if req.query.start is unspecified
* @param {function} [options.query] Async function called as `(req, res, settings)` which can return an object further used to filter down the query data, this should match any valid aggregation $match syntax
* @param {boolean} [options.passthru=false] If falsy req.send is called with the calculated timeseries, if falsy this function populates `req.timeSeries` and passes control to the next express middleware function
* @param {object} [options.output] Aggregation $bucket output as per https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/#std-label-bucket-output
*/
app.middleware.express.timeSeries = options => {
	const settings = {
		collection: undefined,
		field: 'created',
		field2: 'status',
		// FIXME: Warn when enum is undefined
		values: (req, res, settings) => _.get(app.db, [settings.collection, 'schema', 'paths', settings.field2, 'options', 'enum']),
		valueLabel: (key, offset, dataSet, settings) => _.startCase(key),
		fixDates: true,
		start: (req, res) => (req.query.start ? moment(req.query.start) : moment().subtract(1, 'week')).startOf('day'),
		end: (req, res) => (req.query.end ? moment(req.query.end) : moment()).endOf('day'),
		interval: (req, res) => (req.query.interval) ? req.query.interval : { days: 1 },
		timeLabel: (req, res, date) => (req.query.timeLabel) ? moment(date).format(req.query.timeLabel) : moment(date).format('ddd Do MMM'),
		passthru: false,
		query: (req, res) => ({}),
		...options,
	};
	if (!settings.collection) throw new Error('Collection must be specified for app.middleware.express.timeseries()');
	//debug('settings', settings);

	return (req, res, next) => {
		let boundaries = [];
		let labels = [];

		return Promise.resolve()
			.then(()=> Promise.all([
				Promise.resolve(settings.start(req, res, settings)),
				Promise.resolve(settings.end(req, res, settings)),
				Promise.resolve(settings.interval(req, res, settings)),
				Promise.resolve(settings.values(req, res, settings)),
				Promise.resolve(settings.query(req, res, settings))
					.then(query => _.pickBy(query, (v, k) => v !== undefined)), // Remove duds from query
			]))
			.then(([start, end, interval, values, query]) => {
				debug('start', req.query.start, start.format());
				const iter = start;

				while (iter.isBefore(end)) {
					boundaries.push(iter.format()); // Keep as localtime rather than converting to date
					iter.add(interval); // Passing the duration config directly ensures correct context for leap years etc
				}

				// Determine labels based on localtime before proceeding
				debug('interval', req.query.interval, interval);
				debug('boundaries (str)', boundaries, boundaries.length);
				labels = boundaries.map(b => settings.timeLabel(req, res, b));

				// Always add last boundry to keep Mongo / Buckets happy, we remove this at the end
				// This is to avoid fence-bost / off-by-one errors where today's stats don't get caught in the bucket collection from Mongo
				boundaries.push(iter.format());

				// Convert localtime to Date object consequently UTC for Mongo
				// FIXME: UTC? Implied?
				boundaries = boundaries.map(b => moment(b).toDate());
				debug('boundaries (date)', boundaries, boundaries.length);
				debug('labels', labels, labels.length);
				//debug('query', query);
				//debug('values', values);

				return {values, query};
			})
			.then(({values, query}) => {
				const aggregation = [{$facet: _(values)
					.mapKeys()
					.mapValues(val => ([
						{$match: {
							[settings.field2]: val,
							..._.omit(query, [settings.field2]),
						}},
						...(settings.fixDates // Optionally fix date conversion
							? [{$project: {
								[settings.field]: {$toDate: '$' + settings.field},
								[settings.field2]: 1,
								// FIXME: What if output is not defined?
								..._(settings.output)
									.mapValues(() => 1)
									.value(),
							}}]
							: []
						),
						{$bucket: {
							groupBy: '$' + settings.field,
							default: 'unparsable',
							boundaries,
							...(settings.output && Object.keys(settings.output).length > 0) ? { output: settings.output } : {},
						}},
					]))
					.value()
				}];
				debug('aggregation', JSON.stringify(aggregation, null, 2));
				return app.db[settings.collection].aggregate(aggregation);
			})
			.then(dataSets => {
				//debug('dataSets', JSON.stringify(dataSets, null, 2));
				boundaries.pop(); // Remove last, dud boundry mark
				return dataSets[0]; // Return only first matching dataset
			})
			.then(dataSets => Object.keys(dataSets).map((k, kOffset) => {
				const dataSet = dataSets[k];
				const dataSetMap = _(dataSet)
					.mapKeys('_id')
					.mapValues(d => {
						if (!settings.output) {
							return d.count;
						} else if (Object.keys(settings.output).length === 1) {
							return d[Object.keys(settings.output)[0]];
						} else if (Object.keys(settings.output).length > 1) {
							return _.pick(d, Object.keys(settings.output))
						}
					})
					.value();
				//debug('dataSetMap', JSON.stringify(dataSetMap, null, 2));

				return {
					label: settings.valueLabel(k, kOffset, dataSet, settings),
					data: boundaries.map(b => dataSetMap[b] || 0), // Fill in blanks for the sparce dataSet Mongo gives us back
				};
			}))
			.then(datasets => ({
				boundaries,
				datasets,
				labels,
			}))
			.then(data => {
				if (settings.passthru) {
					req.timeSeries = data;
					next();
				} else {
					res.send(data);
				}
			})
			.catch(res.sendError)
	};
};
</script>